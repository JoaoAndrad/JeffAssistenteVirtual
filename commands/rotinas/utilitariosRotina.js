const { obterRotinas, atualizarRotinas } = require("../firebaseFolder/rotinasFirebase");
const schedule = require("node-schedule");
const moment = require("moment-timezone");
const { simularDigitar } = require("../utilitariosComandos");
const { sendGroqChat } = require("../../routes/groq");

const lembretesAtivos = {}; // Estado para rastrear lembretes ativos

// Fun√ß√£o para validar o formato de hor√°rio
function validarFormatoHora(time) {
    const regex = /^\d{2}:\d{2}$/;
    return regex.test(time);
}

// Fun√ß√£o para formatar a resposta das rotinas
function formatRoutineResponse(routines) {
    if (!routines || routines.length === 0) {
        return "Nenhuma rotina encontrada.";
    }

    let response = "üìã Rotinas Programadas:\n";
    routines.forEach(([time, message, status, repetition], index) => {
        response += `${index + 1}. ${time} - ${message} (${status}) - Repeti√ß√£o: ${repetition}\n`;
    });

    return response;
}

// Fun√ß√£o para obter todas as rotinas do Firebase
async function obterRotinasFromFirebase() {
    let routines = await obterRotinas(); // Ler as rotinas do Firebase

    // Remover rotinas unicas inativas ou marcadas como n√£o realizadas
    routines = (routines || []).filter((routine) => {
        const [id, , , , status, , type, , , , , ] = routine;
        // Se for rotina unica e est√° inativa ou n√£o realizada, remove
        if (type === "unica" && (status === "Inativo" || status === "nao_realizada")) {
            // Apagar do Firebase
            atualizarRotinas(id, { deletar: true }).catch(() => {});
            return false;
        }
        // Se for tarefa n√£o repetitiva e suspensa, remove
        if (type !== "repetitiva" && status === "nao_realizada") {
            atualizarRotinas(id, { deletar: true }).catch(() => {});
            return false;
        }
        return true;
    });

    // Log para depura√ß√£o
    //console.log("[DEBUG] Dados brutos retornados por obterRotinas:", routines);

    // Garantir que os dados estejam limpos
    const cleanedRoutines = (routines || []).map((routine) => {
        return routine.map((field) => (field ? field.toString().trim() : "N/A"));
    });

    // Log para verificar os dados limpos
    //console.log("[DEBUG] Dados limpos:", cleanedRoutines);

    return cleanedRoutines;
}

// Fun√ß√£o para agendar uma rotina usando o campo proximoLembrete
function scheduleRoutine(id, time, days, message, repetition, sock, isTask, completed, userId, proximoLembrete, type) {
    const timeZone = "America/Sao_Paulo";

    // Validar se o userId foi fornecido
    if (!userId) {
        console.error(`[ERRO] userId n√£o fornecido para a rotina ID ${id}. N√£o √© poss√≠vel agendar notifica√ß√£o.`);
        return;
    }

    // Usar o proximoLembrete se fornecido, sen√£o calcular
    let nextReminderDate;
    if (proximoLembrete && proximoLembrete !== "N/A") {
        nextReminderDate = moment.tz(proximoLembrete, "YYYY-MM-DD HH:mm:ss", timeZone);
    } else {
        // Fallback: calcular o primeiro lembrete
        const firstReminder = calculateFirstReminder(time, days, repetition, type);
        nextReminderDate = moment.tz(firstReminder, "YYYY-MM-DD HH:mm:ss", timeZone);
    }

    // Verificar se a data/hora j√° passou - se sim, n√£o agendar
    if (nextReminderDate.isBefore(moment.tz(timeZone))) {
        console.log(`[LOG] ‚ö†Ô∏è Ignorando agendamento para data passada: ${nextReminderDate.format("YYYY-MM-DD HH:mm:ss")}`);

        // Para rotinas repetitivas, calcular o pr√≥ximo lembrete v√°lido
        if (type === "repetitiva") {
            const nextValidReminder = calculateNextReminder(nextReminderDate.format("YYYY-MM-DD HH:mm:ss"), repetition, time, days);
            nextReminderDate = moment.tz(nextValidReminder, "YYYY-MM-DD HH:mm:ss", timeZone);

            // Atualizar o proximoLembrete no Firebase
            atualizarRotinas(id, { proximoLembrete: nextValidReminder }).catch(error => {
                console.error(`[ERRO] Falha ao atualizar proximoLembrete para rotina ID ${id}:`, error);
            });
        } else {
            return; // Para rotinas unicas passadas, n√£o agendar
        }
    }

    const localTime = nextReminderDate.format("YYYY-MM-DD HH:mm:ss");
    const utcTime = nextReminderDate.utc().format("YYYY-MM-DD HH:mm:ss");

    // Ajuste: exibir "Evento √∫nico" para rotinas unicas
    const repeticaoExibida = (type === "unica") ? "Evento √∫nico" : (repetition || "N/A");

    console.log(` 
        [LOG] Criando lembrete:
        - ID: ${id}
        - UserId: ${userId}
        - Tipo: ${type}
        - Dias: ${days}
        - Mensagem: "${message}"
        - Pr√≥ximo Lembrete: ${localTime}
        - Hor√°rio UTC: ${utcTime}
        - Repeti√ß√£o: ${repeticaoExibida}
        - √â tarefa: ${isTask ? "Sim" : "N√£o"}
    `);

    schedule.scheduleJob(nextReminderDate.toDate(), async () => {
        console.log(`[LOG] Enviando lembrete para a rotina ID ${id} ao usu√°rio ${userId}: "${message}"`);
        try {
            // Criar momento atual no fuso hor√°rio correto para formata√ß√£o
            const nowLocal = moment.tz(timeZone);
            const reminderTimeLocal = moment.tz(nextReminderDate, timeZone);

            let messageText = `üîî *${isTask ? 'Tarefa' : 'Lembrete'}:*\n\nüìù "${message}"\n\nüïí *Hor√°rio:* ${reminderTimeLocal.format("HH:mm")}\nüìÖ *Data:* ${reminderTimeLocal.format("DD/MM/YYYY")}`;

            if (isTask) {
                messageText += `\n\nüìå *Esta √© uma TAREFA!* 
                
üîî *IMPORTANTE:* Ap√≥s completar a tarefa, responda:
‚Ä¢ ‚úÖ \`SIM\` - para marcar como conclu√≠da
‚Ä¢ ‚û°Ô∏è \`DEPOIS\` - para adiar e ser lembrado novamente em 1 hora
‚Ä¢ üö´ \`N√ÉO VOU FAZER\` - para suspender futuros lembretes

üí° *Dica:* Voc√™ pode responder a qualquer momento, mesmo agora!`;

                // Encerrar qualquer estado pendente anterior para este usu√°rio
                if (lembretesAtivos[userId]) {
                    console.log(`[LOG] Encerrando estado pendente anterior para usu√°rio ${userId} - Tarefa ID ${lembretesAtivos[userId].id}: "${lembretesAtivos[userId].message}"`);
                    delete lembretesAtivos[userId];
                }

                // Definir a nova tarefa como pendente IMEDIATAMENTE
                lembretesAtivos[userId] = { id, message, isFirstAsk: false };
                console.log(`[LOG] Nova tarefa notificada para usu√°rio ${userId} - ID ${id}: "${message}" - Estado pendente ATIVO`);
            }

            await simularDigitar(sock, userId);
            await sock.sendMessage(userId, { text: messageText });

            // Para rotinas repetitivas, calcular e agendar o pr√≥ximo lembrete
            if (type === "repetitiva") {
                const nextReminder = calculateNextReminder(localTime, repetition, time, days);
                await atualizarRotinas(id, { proximoLembrete: nextReminder });
                console.log(`[LOG] Pr√≥ximo lembrete agendado para rotina ID ${id}: ${nextReminder}`);

                // Reagendar automaticamente para o pr√≥ximo ciclo
                scheduleRoutine(id, time, days, message, repetition, sock, isTask, completed, userId, nextReminder, type);
            } else {
                // Para rotinas unicas, marcar como inativa ap√≥s o lembrete
                // Se n√£o for tarefa e n√£o tem repeti√ß√£o, apagar a rotina
                if (!isTask && (!repetition || repetition === "N/A")) {
                    await atualizarRotinas(id, { deletar: true });
                    console.log(`[LOG] Rotina √∫nica n√£o-tarefa ID ${id} apagada ap√≥s lembrete.`);
                } else {
                    await atualizarRotinas(id, {
                        status: "Inativo",
                        proximoLembrete: "N/A"
                    });
                    console.log(`[LOG] Rotina √∫nica ID ${id} marcada como inativa ap√≥s lembrete.`);
                }
            }

            if (isTask) {
                // Perguntar ap√≥s 10 minutos se a tarefa foi conclu√≠da
                const followUpDate = reminderTimeLocal.clone().add(10, "minutes");
                schedule.scheduleJob(followUpDate.toDate(), async () => {
                    console.log(`[LOG] Perguntando sobre a conclus√£o da tarefa ID ${id} ao usu√°rio ${userId} ap√≥s 10 minutos`);
                    await sock.sendMessage(userId, {
                        text: `‚ùì *VERIFICA√á√ÉO DE TAREFA* ‚ùì\n\nüìù Voc√™ j√° concluiu a tarefa: *"${message}"*?\n\n‚úÖ Responda \`SIM\` se j√° fez\n‚ùå Responda \`DEPOIS\` se ainda n√£o fez\nüö´ Responda \`N√ÉO VOU FAZER\` para cancelar\n\n‚è∞ *Esta √© uma verifica√ß√£o autom√°tica ap√≥s 10 minutos*`
                    });

                    // N√£o sobrescrever se j√° existe um activeReminder
                    if (!lembretesAtivos[userId]) {
                        lembretesAtivos[userId] = { id, message, isFirstAsk: true };
                    }
                    // Atualizar proximoLembrete para o followUpDate
                    try {
                        await atualizarRotinas(id, { proximoLembrete: followUpDate.format("YYYY-MM-DD HH:mm:ss") });
                        console.log(`[LOG] proximoLembrete atualizado para tarefa ID ${id}: ${followUpDate.format("YYYY-MM-DD HH:mm:ss")}`);
                    } catch (error) {
                        console.error(`[ERRO] Falha ao atualizar proximoLembrete para tarefa ID ${id}:`, error);
                    }
                });
            }
        } catch (error) {
            console.error(`[ERRO] Falha ao enviar notifica√ß√£o para o usu√°rio ${userId}:`, error);
        }
    });
}

// Fun√ß√£o para converter o nome do dia para o √≠ndice do `node-schedule`
function obterDiaDaSemana(day) {
    const diasDaSemana = {
        domingo: 0,
        segunda: 1,
        ter√ßa: 2,
        terca: 2, // Adicionado para lidar com strings sanitizadas
        quarta: 3,
        quinta: 4,
        sexta: 5,
        s√°bado: 6,
        sabado: 6 // Adicionado para lidar com strings sanitizadas
    };
    return diasDaSemana[day] || null; // Retorna null se o dia n√£o for v√°lido
}

// Fun√ß√£o para processar respostas de lembretes
async function tratarRespostaDeLembrete(sock, chatId, messageContent) {
    // Se o usu√°rio digitar "sim" e h√° uma tarefa ativa, processar mesmo que n√£o esteja aguardando resposta
    if (messageContent.toLowerCase() === "sim" && lembretesAtivos[chatId]) {
        console.log(`[LOG] tratarRespostaDeLembrete - "sim" detectado com tarefa ativa para chat ${chatId}`);
        // Processar a conclus√£o da tarefa
        const { id, message } = lembretesAtivos[chatId];
        console.log(`[LOG] tratarRespostaDeLembrete - Processando conclus√£o da tarefa ID ${id}: "${message}"`);
        await processTaskCompletion(sock, chatId, id, message);
        return true;
    }
    if (!lembretesAtivos[chatId]) {
        return false; // N√£o h√° lembrete ativo para este chat
    }
    const { id, message, isFirstAsk } = lembretesAtivos[chatId];
    const normalizedMessage = messageContent.toLowerCase().trim();
    console.log(`[LOG] tratarRespostaDeLembrete - Processando resposta "${normalizedMessage}" para tarefa ID ${id}`);

    if (normalizedMessage.includes("sim") || normalizedMessage === "s" || normalizedMessage === "yes" || normalizedMessage === "1") {
        console.log(`[LOG] tratarRespostaDeLembrete - Processando "sim" para tarefa ID ${id}`);
        await processTaskCompletion(sock, chatId, id, message);
        
    } else if (normalizedMessage.includes("depois") || normalizedMessage.includes("dps") || normalizedMessage.includes("later") || normalizedMessage === "2") {
        if (isFirstAsk) {
            // Reagendar para 10 minutos
            await simularDigitar(sock, chatId);
            await sock.sendMessage(chatId, {
                text: `üîÑ *Entendido!*\n\nVou lembr√°-lo novamente em 10 minutos sobre a tarefa:\nüìù "${message}"`
            });
            const tenMinutesLater = moment().add(10, 'minutes');
            schedule.scheduleJob(tenMinutesLater.toDate(), async () => {
                await sock.sendMessage(chatId, {
                    text: `‚ùì *Lembrete de Tarefa (10 min depois):*\n\nVoc√™ j√° concluiu a tarefa: "${message}"?\n\nResponda com "Sim" ou "Depois".`
                });
                lembretesAtivos[chatId] = { id, message, isFirstAsk: true };
                await atualizarRotinas(id, { proximoLembrete: tenMinutesLater.format("YYYY-MM-DD HH:mm:ss") });
            });
            await atualizarRotinas(id, { proximoLembrete: tenMinutesLater.format("YYYY-MM-DD HH:mm:ss") });
        } else {
            // Reagendar para 1 hora
            await simularDigitar(sock, chatId);
            await sock.sendMessage(chatId, {
                text: `üîÑ *Entendido!*\n\nVou lembr√°-lo novamente em 1 hora sobre a tarefa:\nüìù "${message}"`
            });
            const oneHourLater = moment().add(1, 'hour');
            schedule.scheduleJob(oneHourLater.toDate(), async () => {
                await sock.sendMessage(chatId, {
                    text: `‚ùì *Lembrete de Tarefa (1h depois):*\n\nVoc√™ j√° concluiu a tarefa: "${message}"?\n\nResponda com "Sim" ou "Depois".`
                });
                lembretesAtivos[chatId] = { id, message, isFirstAsk: false };
                await atualizarRotinas(id, { proximoLembrete: oneHourLater.format("YYYY-MM-DD HH:mm:ss") });
            });
            await atualizarRotinas(id, { proximoLembrete: oneHourLater.format("YYYY-MM-DD HH:mm:ss") });
        }
        lembretesAtivos[chatId] = { id, message, isFirstAsk: isFirstAsk };
    } else if (normalizedMessage.includes('n√£o vou fazer') ||
        normalizedMessage.includes('nao vou fazer') ||
        normalizedMessage.includes('n√£o farei') ||
        normalizedMessage.includes('nao farei') ||
        normalizedMessage.includes('desisti') ||
        normalizedMessage.includes('deixa') ||
        normalizedMessage.includes('cancelar')) {

        console.log(`[LOG] Usu√°rio ${chatId} escolheu suspender a tarefa ID ${id}`);

        try {
            // Marcar como "n√£o realizada" no Firebase
            await atualizarRotinas(id, {
                ultimaExecucao: new Date().toISOString(),
                status: 'nao_realizada',
                proximoLembrete: null // Remove pr√≥ximo lembrete
            });

            // Remover do estado ativo
            delete lembretesAtivos[chatId];

            await simularDigitar(sock, chatId);
            await sock.sendMessage(chatId, {
                text: `‚úÖ Entendi! A tarefa "${message}" foi marcada como *n√£o realizada* e os lembretes foram suspensos.\n\nüí° Se mudar de ideia, voc√™ pode criar uma nova rotina.`
            });

            console.log(`[LOG] Tarefa ID ${id} suspensa com sucesso`);

        } catch (error) {
            console.error(`[ERRO] Falha ao suspender tarefa ID ${id}:`, error);
            await sock.sendMessage(chatId, {
                text: "‚ùå Houve um erro ao suspender a tarefa. Tente novamente."
            });
        }
    } else {
        await simularDigitar(sock, chatId);
        await sock.sendMessage(chatId, {
            text: `‚ùì *Resposta Inv√°lida!*\n\nPor favor, responda apenas com:\n- "Sim"\n- "Depois"\n- "N√£o vou fazer"\n\nüìù *Tarefa:* "${message}"`
        });
    }

    return true;
}

// Fun√ß√£o auxiliar para processar a conclus√£o de uma tarefa
async function processTaskCompletion(sock, chatId, id, message) {
    console.log(`[LOG] processTaskCompletion - Iniciando processamento para chat ${chatId}, tarefa ID ${id}`);
    console.log(`[LOG] processTaskCompletion - Mensagem da tarefa: "${message}"`);

    try {
        console.log(`[LOG] processTaskCompletion - Buscando rotinas no Firebase...`);
        const routines = await obterRotinas();
        console.log(`[LOG] processTaskCompletion - ${routines.length} rotinas encontradas`);

        const targetRoutine = routines.find((routine) => routine[0] === id.toString());
        if (!targetRoutine) {
            console.error(`[ERRO] processTaskCompletion - Tarefa com ID ${id} n√£o encontrada no Firebase.`);
            await simularDigitar(sock, chatId);
            await sock.sendMessage(chatId, {
                text: "‚ùå *Erro:* N√£o foi poss√≠vel localizar a tarefa no Firebase. Verifique os logs."
            });
            return;
        }

        console.log(`[LOG] processTaskCompletion - Tarefa encontrada: ${JSON.stringify(targetRoutine)}`);

        const completionDate = moment().tz("America/Sao_Paulo").format("YYYY-MM-DD HH:mm:ss");
        console.log(`[LOG] processTaskCompletion - Data de conclus√£o: ${completionDate}`);

        const routineType = targetRoutine[6]; // Coluna "Tipo" (unica ou repetitiva)

        // Atualizar no Firebase
        if (routineType === "unica") {
            // Rotinas unicas: marcar como conclu√≠da e inativar
            await atualizarRotinas(id, {
                status: "Inativo",
                completed: "Sim",
                completionDate: completionDate
            });
            console.log(`[LOG] Rotina unica ID ${id} marcada como conclu√≠da e inativada.`);
        } else {
            // Rotinas repetitivas: marcar como conclu√≠da temporariamente
            // Mas agendar redefini√ß√£o para permitir pr√≥ximos lembretes
            await atualizarRotinas(id, {
                completed: "Sim",
                completionDate: completionDate
            });
            console.log(`[LOG] Rotina repetitiva ID ${id} marcada como conclu√≠da temporariamente.`);

            // Para tarefas repetitivas, redefinir status em 30 minutos para permitir pr√≥ximos agendamentos
            const resetTime = moment().add(30, 'minutes');
            schedule.scheduleJob(resetTime.toDate(), async () => {
                try {
                    await atualizarRotinas(id, {
                        completed: "N√£o",
                        completionDate: "N/A"
                    });
                    console.log(`[LOG] Status da tarefa repetitiva ID ${id} redefinido automaticamente ap√≥s conclus√£o.`);
                } catch (error) {
                    console.error(`[ERRO] Falha ao redefinir tarefa repetitiva ID ${id}:`, error);
                }
            });
        }

        await simularDigitar(sock, chatId);
        await sock.sendMessage(chatId, {
            text: `‚úÖ *Tarefa Conclu√≠da!*\n\nüìù *Tarefa:* "${message}"\n\nüïí *Hor√°rio:* ${moment().tz("America/Sao_Paulo").format("HH:mm")}\nüìÖ *Data:* ${moment().tz("America/Sao_Paulo").format("DD/MM/YYYY")}`
        });

        delete lembretesAtivos[chatId];
    } catch (error) {
        console.error("[ERRO] Falha ao atualizar no Firebase:", error);
        await simularDigitar(sock, chatId);
        await sock.sendMessage(chatId, {
            text: "‚ùå *Erro:* N√£o foi poss√≠vel atualizar a tarefa no Firebase. Verifique os logs."
        });
    }
}

async function iniciarLembretes(sock, routines) {
    console.log("[LOG] Inicializando lembretes...");
    routines.forEach(async ([id, time, days, message, status, repetition, type, isTask, completed, completionDate, userId, proximoLembrete]) => {
        if (status === "Ativo") {
            // Para rotinas unicas conclu√≠das, n√£o agendar novamente
            if (type === "unica" && completed === "Sim") {
                console.log(`[LOG] Ignorando rotina unica conclu√≠da ID ${id}`);
                return;
            }

            // Para rotinas repetitivas, sempre agendar independentemente do status de conclus√£o
            // pois elas devem continuar nos pr√≥ximos ciclos
            console.log(`[DEBUG] Agendando rotina ID ${id} com proximoLembrete: ${proximoLembrete}`);

            // Se for tarefa e proximoLembrete est√° no futuro, reagendar verifica√ß√£o
            if (isTask === "Sim" && proximoLembrete && proximoLembrete !== "N/A") {
                const now = moment.tz("America/Sao_Paulo");
                const proximo = moment.tz(proximoLembrete, "YYYY-MM-DD HH:mm:ss", "America/Sao_Paulo");
                if (proximo.isAfter(now)) {
                    lembretesAtivos[userId] = { id, message, isFirstAsk: true };
                    schedule.scheduleJob(proximo.toDate(), async () => {
                        await sock.sendMessage(userId, {
                            text: `‚ùì *Lembrete de Tarefa (verifica√ß√£o):*\n\nVoc√™ j√° concluiu a tarefa: "${message}"?\n\nResponda com \`Sim\`, \`Depois\` ou \`cancelar\`.`
                        });
                        lembretesAtivos[userId] = { id, message, isFirstAsk: true };
                    });
                }
            } else {
                // Chamar scheduleRoutine para agendar a rotina
                scheduleRoutine(id, time, days, message, repetition, sock, isTask === "Sim", completed, userId, proximoLembrete, type);
            }
        }
    });
    console.log("[LOG] Lembretes inicializados com sucesso.");
}

async function initializeSingleReminder(sock) {
    console.log("[LOG] Inicializando lembrete para a √∫ltima rotina salva...");

    // Obter todas as rotinas da planilha
    const routines = await obterRotinas();
    if (!routines || routines.length === 0) {
        console.error("[ERRO] Nenhuma rotina encontrada para inicializar.");
        return;
    }

    // Selecionar a √∫ltima rotina salva
    const routine = routines[routines.length - 1];
    const [id, time, days, message, status, repetition, type, isTask, completed, completionDate, userId, proximoLembrete] = routine;

    if (status === "Ativo") {
        console.log(`[DEBUG] Agendando √∫ltima rotina salva ID ${id} com proximoLembrete: ${proximoLembrete}`);

        // Chamar scheduleRoutine para agendar a nova rotina
        scheduleRoutine(id, time, days, message, repetition, sock, isTask === "Sim", completed, userId, proximoLembrete, type);
    }
    console.log("[LOG] Lembrete inicializado com sucesso para a √∫ltima rotina salva.");
}

// Fun√ß√£o para redefinir o status de conclus√£o de tarefas repetitivas
async function resetarTarefasRepetitivas() {
    try {
        const routines = await obterRotinas();

        for (const routine of routines) {
            const [id, , , , status, , type, , completed] = routine;

            // Verificar se √© uma tarefa repetitiva e est√° marcada como conclu√≠da
            if (type === "repetitiva" && completed === "Sim") {
                await atualizarRotinas(id, {
                    completed: "N√£o",
                    completionDate: "N/A"
                }); // Redefinir status e limpar data de conclus√£o
                console.log(`[LOG] Tarefa repetitiva ID ${id} redefinida para "N√£o conclu√≠da".`);
            }
        }
    } catch (error) {
        console.error("[ERRO] Falha ao redefinir tarefas repetitivas:", error);
    }
}

// Remova o agendamento di√°rio
// schedule.scheduleJob("0 0 * * *", async () => {
//     console.log("[LOG] Executando redefini√ß√£o de tarefas repetitivas...");
//     await resetarTarefasRepetitivas();
// });

function pegarDataHoje() {
    return moment.tz("America/Sao_Paulo").format("YYYY-MM-DD");
}

// Fun√ß√£o para calcular o pr√≥ximo lembrete baseado na repeti√ß√£o
function calculateNextReminder(dataAtual, repetition, time, days) {
    const timeZone = "America/Sao_Paulo";
    const [hour, minute] = time.split(":").map(Number);

    let nextDate = moment.tz(dataAtual, timeZone).hour(hour).minute(minute).second(0).millisecond(0);

    switch (repetition) {
        case "diariamente":
            nextDate.add(1, 'day');
            break;

        case "semanalmente":
            nextDate.add(1, 'week');
            break;

        case "a cada 2 semanas":
            nextDate.add(2, 'weeks');
            break;

        case "mensalmente":
            nextDate.add(1, 'month');
            break;

        case "anualmente":
            nextDate.add(1, 'year');
            break;

        default:
            // Para rotinas com dias espec√≠ficos da semana
            if (days !== "todos" && days.includes(",")) {
                const dayNames = days.split(",").map(d => d.trim().toLowerCase());
                const dayIndices = dayNames.map(d => obterDiaDaSemana(d)).filter(d => d !== null);

                // Encontrar o pr√≥ximo dia da semana na lista
                const currentDayIndex = nextDate.day();
                let foundNext = false;

                for (let i = 0; i < 7 && !foundNext; i++) {
                    const targetDay = (currentDayIndex + i + 1) % 7;
                    if (dayIndices.includes(targetDay)) {
                        nextDate.day(targetDay);
                        if (i === 0 && nextDate.isBefore(moment.tz(timeZone))) {
                            // Se √© hoje mas j√° passou o hor√°rio, vai para pr√≥xima semana
                            nextDate.add(1, 'week');
                        }
                        foundNext = true;
                    }
                }

                if (!foundNext) {
                    // Se n√£o encontrou, vai para a pr√≥xima semana com o primeiro dia da lista
                    nextDate.day(dayIndices[0]).add(1, 'week');
                }
            } else if (days !== "todos") {
                // Dia √∫nico da semana
                const dayIndex = obterDiaDaSemana(days.trim().toLowerCase());
                if (dayIndex !== null) {
                    nextDate.add(1, 'week');
                }
            }
            break;
    }

    return nextDate.format("YYYY-MM-DD HH:mm:ss");
}

// Fun√ß√£o para calcular o primeiro lembrete de uma nova rotina
function calculateFirstReminder(time, days, repetition, type) {
    const timeZone = "America/Sao_Paulo";
    const [hour, minute] = time.split(":").map(Number);
    const now = moment.tz(timeZone);

    if (type === "unica") {
        // Para rotinas unicas, usar a data espec√≠fica
        if (moment(days, "YYYY-MM-DD", true).isValid()) {
            return moment.tz(days, "YYYY-MM-DD", timeZone).hour(hour).minute(minute).second(0).millisecond(0).format("YYYY-MM-DD HH:mm:ss");
        }
        // Se for "hoje"
        const today = now.clone().hour(hour).minute(minute).second(0).millisecond(0);
        return today.format("YYYY-MM-DD HH:mm:ss");
    }

    // Para rotinas repetitivas
    if (days === "todos") {
        // Verificar se ainda n√£o passou o hor√°rio de hoje
        const today = now.clone().hour(hour).minute(minute).second(0).millisecond(0);
        if (today.isAfter(now)) {
            return today.format("YYYY-MM-DD HH:mm:ss");
        } else {
            return today.add(1, 'day').format("YYYY-MM-DD HH:mm:ss");
        }
    }

    if (days.includes(",")) {
        // M√∫ltiplos dias da semana
        const dayNames = days.split(",").map(d => d.trim().toLowerCase());
        const dayIndices = dayNames.map(d => obterDiaDaSemana(d)).filter(d => d !== null);
        const currentDayIndex = now.day();

        // Verificar se hoje √© um dos dias e ainda n√£o passou o hor√°rio
        if (dayIndices.includes(currentDayIndex)) {
            const today = now.clone().hour(hour).minute(minute).second(0).millisecond(0);
            if (today.isAfter(now)) {
                return today.format("YYYY-MM-DD HH:mm:ss");
            }
        }

        // Encontrar o pr√≥ximo dia da lista
        for (let i = 1; i <= 7; i++) {
            const targetDay = (currentDayIndex + i) % 7;
            if (dayIndices.includes(targetDay)) {
                const nextDate = now.clone().day(targetDay).hour(hour).minute(minute).second(0).millisecond(0);
                if (i > 0) {
                    return nextDate.format("YYYY-MM-DD HH:mm:ss");
                }
            }
        }
    } else {
        // Dia √∫nico da semana
        const dayIndex = obterDiaDaSemana(days.trim().toLowerCase());
        if (dayIndex !== null) {
            const currentDayIndex = now.day();
            let nextDate = now.clone().day(dayIndex).hour(hour).minute(minute).second(0).millisecond(0);

            // Se √© hoje mas j√° passou o hor√°rio, ou se j√° passou este dia da semana
            if (dayIndex < currentDayIndex || (dayIndex === currentDayIndex && nextDate.isBefore(now))) {
                nextDate.add(1, "week");
            }

            return nextDate.format("YYYY-MM-DD HH:mm:ss");
        }
    }

    // Fallback: amanh√£ no mesmo hor√°rio
    return now.clone().add(1, 'day').hour(hour).minute(minute).second(0).millisecond(0).format("YYYY-MM-DD HH:mm:ss");
}

/**
 * Analisa uma mensagem de rotina usando Groq LLM e retorna os campos estruturados.
 * Se mencionar um dia numeral (ex: "dia 7 tenho que...") e n√£o for recorrente, agendar para o pr√≥ximo m√™s se o dia j√° passou.
 * Sempre retorna os campos: dayOrDate, time, message, type, repetition (quando aplic√°vel).
 * @param {string} texto
 * @returns {Promise<{dayOrDate: string, time: string, message: string, type: string, repetition?: string}|null>} Retorna os campos ou null se falhar
 */
async function analisarRotinaViaGroq(texto) {
    try {
        const saoPauloNow = moment.tz("America/Sao_Paulo");
        const dataAtual = saoPauloNow.format("YYYY-MM-DD");
        const horaAtual = saoPauloNow.format("HH:mm");
        const diaAtual = saoPauloNow.date();
        const mesAtual = saoPauloNow.month() + 1;
        const anoAtual = saoPauloNow.year();
        // Fun√ß√£o auxiliar para calcular pr√≥xima data para qualquer dia numeral
        function proximaDataNumeral(dia) {
            let diaNum = parseInt(dia, 10);
            if (isNaN(diaNum) || diaNum < 1 || diaNum > 31) return null;
            let data = moment.tz(`${anoAtual}-${mesAtual.toString().padStart(2, '0')}-${diaNum.toString().padStart(2, '0')}`, "YYYY-MM-DD", "America/Sao_Paulo");
            if (data.isBefore(saoPauloNow, 'day')) {
                data = data.add(1, 'month');
            }
            return data.format("YYYY-MM-DD");
        }
        const prompt = [
            `Hor√°rio atual em S√£o Paulo: ${dataAtual} ${horaAtual}`,
            "Sua tarefa √© extrair os campos estruturados da mensagem abaixo e convert√™-la em um lembrete ou rotina.",
            "Sempre responda SOMENTE em JSON v√°lido, sem explica√ß√µes, coment√°rios ou texto adicional.",
            "",
            "üß† Objetivo:",
            "- Interpretar mensagens em linguagem natural para estruturar lembretes e rotinas com base no conte√∫do textual.",
            "üìÖ Regras para interpreta√ß√£o de datas:",
            "- Use o hor√°rio atual informado no topo para base de c√°lculo.",
            "- Quando o usu√°rio mencionar apenas um dia numeral (ex: 'dia 10'), e o dia atual for maior que esse n√∫mero, agende para o m√™s seguinte.",
            "- Quando houver datas no formato DD/MM ou DD/MM/YYYY, normalize para 'YYYY-MM-DD'.",
            "- Para dias da semana como 'ter√ßa-feira' 'ter√ßa' 'quarta-feira' 'pr√≥xima quarta' 'nessa quinta' 'essa quinta-feira', calcule a pr√≥xima ocorr√™ncia (nunca datas passadas).",
            "- Palavras como 'amanh√£', 'depois de amanh√£', 'semana que vem' devem ser convertidas para a data correta baseada em 'dataAtual'.",
            "",
            "‚è∞ Regras para interpreta√ß√£o de tempo:",
            "- Hor√°rios devem sempre ser convertidos para o formato 24h (ex: '8 da noite' -> '20:00').",
            "- Interpreta√ß√µes relativas como 'em 2 horas', 'daqui a 30 minutos' devem ser calculadas com base em horaAtual.",
            "- Se a mensagem n√£o tiver hor√°rio expl√≠cito nem relativo, defina: \"time\": \"\"",
            "",
            "üîÅ Regras para mensagens recorrentes:",
            "- Termos como 'todo', 'toda', 'sempre', 'diariamente', 'semanalmente', 'mensalmente' indicam repeti√ß√£o.",
            "- Use: type: 'repetitiva' e o campo repetition com: 'diariamente', 'semanalmente', 'mensalmente', etc.",
            "- Exemplo: 'todo s√°bado', repetition: 'semanalmente', dayOrDate: 's√°bado'",
            "- Repeti√ß√µes num√©ricas: 'todo dia 10' -> dayOrDate: '10', repetition: 'mensalmente' type: 'repetitiva'",
            "",
            "üßº Regras para o campo 'message':",
            "- Remova termos desnecess√°rios como: 'me lembra de', 'tenho que', 'preciso', 'vou', 'lembrar de', 'agendar', 'programar'.",
            "- Mantenha a descri√ß√£o limpa, direta e concisa.",
            "",
            "‚úÖ Quando usar o campo 'isTask':",
            "- Use \"isTask\": true para compromissos relevantes (reuni√µes, consultas, tomar rem√©dio, pagar contas, tarefas com a√ß√£o).",
            "- Evite usar para eventos informais (ex: 'ver filme', 'ir ao parque').",
            "",
            "‚ö†Ô∏è Importante:",
            "- Sempre retorne campos com aspas duplas. Use estrutura JSON v√°lida.",
            "- Caso algum dado esteja ausente (ex: sem hor√°rio), ainda assim responda com os demais campos e time como \"\".",
            "- O campo 'Message' jamais pode ter informa√ß√µes que n√£o estejam na mensagem original, se atente a isso, revise duas vezes o contexto da mensagem para garantir que a mensagem ser√° devidamente retirada da frase, mesmo com os exemplos abaixo.",
            "",
            "üìö Exemplos de entrada e sa√≠da:",
            "",
            "Mensagem: 'dia 7 tenho que levar o carro no mec√¢nico' (e hoje √© dia 8 do mes)",
            "Resposta:",
            "{",
            `  "dayOrDate": "${proximaDataNumeral(7)}",`,
            '  "message": "levar o carro no mec√¢nico",',
            '  "type": "unica",',
            '  "isTask": true',
            "}",
            "",
            "Mensagem: 'amanh√£ √†s 14:30 reuni√£o com equipe'",
            "Resposta:",
            "{",
            `  "dayOrDate": "${saoPauloNow.clone().add(1, 'day').format('YYYY-MM-DD')}",`,
            '  "time": "14:30",',
            '  "message": "reuni√£o com equipe",',
            '  "type": "unica",',
            '  "isTask": true',
            "}",
            "",
            "Mensagem: 'todo dia 10 pagar o aluguel'",
            "Resposta:",
            "{",
            '  "dayOrDate": "10",',
            '  "message": "pagar o aluguel",',
            '  "type": "repetitiva",',
            '  "repetition": "mensalmente",',
            '  "isTask": true',
            "}",
            "",
            "Mensagem: 'daqui a 45 minutos ligar para o cliente'",
            "Resposta:",
            "{",
            `  "dayOrDate": "${saoPauloNow.clone().add(45, 'minutes').format('YYYY-MM-DD')}",`,
            `  "time": "${saoPauloNow.clone().add(45, 'minutes').format('HH:mm')}",`,
            '  "message": "ligar para o cliente",',
            '  "type": "unica",',
            '  "isTask": true',
            "}",
            "",
            "Mensagem: 'daqui a 20 minutos eu vou tomar caf√©'",
            "Resposta:",
            "{",
            `  "dayOrDate": "${saoPauloNow.clone().add(20, 'minutes').format('YYYY-MM-DD')}",`,
            `  "time": "${saoPauloNow.clone().add(20, 'minutes').format('HH:mm')}",`,
            '  "message": "tomar caf√©",',
            '  "type": "unica",',
            '  "isTask": true',
            "}",
            "",
            "Mensagem: 'daqui a 45 minutos ligar para o cliente'",
            "Resposta:",
            "{",
            `  "dayOrDate": "${saoPauloNow.clone().add(45, 'minutes').format('YYYY-MM-DD')}",`,
            `  "time": "${saoPauloNow.clone().add(45, 'minutes').format('HH:mm')}",`,
            '  "message": "ligar para o cliente",',
            '  "type": "unica",',
            '  "isTask": true',
            "}",
            "Mensagem: 'daqui 5 minutos enviar e-mail para o cliente'",
            "Resposta:",
            "{",
            `  "dayOrDate": "${saoPauloNow.clone().add(5, 'minutes').format('YYYY-MM-DD')}",`,
            `  "time": "${saoPauloNow.clone().add(5, 'minutes').format('HH:mm')}",`,
            '  "message": "ligar para o cliente",',
            '  "type": "unica",',
            '  "isTask": true',
            "}",

            "Mensagem: 'me lembra de tomar rem√©dio em 15 minutos'",
            "Resposta:",
            "{",
            `  "dayOrDate": "${saoPauloNow.clone().add(15, 'minutes').format('YYYY-MM-DD')}",`,
            `  "time": "${saoPauloNow.clone().add(15, 'minutes').format('HH:mm')}",`,
            '  "message": "tomar rem√©dio",',
            '  "type": "unica",',
            '  "isTask": true',
            "}",

            "Mensagem: 'em 2 horas revisar o relat√≥rio'",
            "Resposta:",
            "{",
            `  "dayOrDate": "${saoPauloNow.clone().add(2, 'hours').format('YYYY-MM-DD')}",`,
            `  "time": "${saoPauloNow.clone().add(2, 'hours').format('HH:mm')}",`,
            '  "message": "revisar o relat√≥rio",',
            '  "type": "unica",',
            '  "isTask": true',
            "}",

            "Mensagem: 'em 5 horas sair para o aeroporto'",
            "Resposta:",
            "{",
            `  "dayOrDate": "${saoPauloNow.clone().add(5, 'hours').format('YYYY-MM-DD')}",`,
            `  "time": "${saoPauloNow.clone().add(5, 'hours').format('HH:mm')}",`,
            '  "message": "sair para o aeroporto",',
            '  "type": "unica",',
            '  "isTask": true',
            "}",

            "Mensagem: 'daqui 2 dias reuni√£o com a equipe'",
            "Resposta:",
            "{",
            `  "dayOrDate": "${saoPauloNow.clone().add(2, 'days').format('YYYY-MM-DD')}",`,
            '  "time": "",',
            '  "message": "reuni√£o com a equipe",',
            '  "type": "unica",',
            '  "isTask": true',
            "}",

            "Mensagem: 'daqui a 3 dias ir ao cinema'",
            "Resposta:",
            "{",
            `  "dayOrDate": "${saoPauloNow.clone().add(3, 'days').format('YYYY-MM-DD')}",`,
            '  "time": "",',
            '  "message": "ir ao cinema",',
            '  "type": "unica"',
            "}",
            "Mensagem: 'revisar o TCC daqui a 2 dias'",
            "Resposta:",
            "{",
            `  "dayOrDate": "${saoPauloNow.clone().add(2, 'days').format('YYYY-MM-DD')}",`,
            '  "time": "",',
            '  "message": "revisar o TCC",',
            '  "type": "unica",',
            '  "isTask": true',
            "}",
            "Mensagem: 'Amanh√£ √†s 10h pegar os exames'",
            "Resposta:",
            "{",
            `  "dayOrDate": "${saoPauloNow.clone().add(1, 'day').format('YYYY-MM-DD')}",`,
            '  "time": "10:00",',
            '  "message": "pegar os exames",',
            '  "type": "unica",',
            '  "isTask": true',
            "}",

            "Mensagem: 'Todo s√°bado √†s 18h ir √† academia'",
            "Resposta:",
            "{",
            '  "dayOrDate": "s√°bado",',
            '  "time": "18:00",',
            '  "message": "ir √† academia",',
            '  "type": "repetitiva",',
            '  "repetition": "semanalmente"',
            "}",

            "Mensagem: 'Me lembra de pagar o aluguel dia 10'",
            "Resposta:",
            "{",
            `  "dayOrDate": "${proximaDataNumeral(10)}",`,
            '  "time": "",',
            '  "message": "pagar o aluguel",',
            '  "type": "unica",',
            '  "isTask": true',
            "}",

            "Mensagem: 'Daqui a 30 minutos ligar para o Jo√£o'",
            "Resposta:",
            "{",
            `  "dayOrDate": "${saoPauloNow.clone().add(30, 'minutes').format('YYYY-MM-DD')}",`,
            `  "time": "${saoPauloNow.clone().add(30, 'minutes').format('HH:mm')}",`,
            '  "message": "ligar para o Jo√£o",',
            '  "type": "unica",',
            "}",

            "Mensagem: 'Consulta m√©dica em 2 dias √†s 9h'",
            "Resposta:",
            "{",
            `  "dayOrDate": "${saoPauloNow.clone().add(2, 'days').format('YYYY-MM-DD')}",`,
            '  "time": "09:00",',
            '  "message": "consulta m√©dica",',
            '  "type": "unica",',
            '  "isTask": true',
            "}",
            "Mensagem: 'daqui uma semana entregar o projeto final'",
            "Resposta:",
            "{",
            `  "dayOrDate": "${saoPauloNow.clone().add(1, 'week').format('YYYY-MM-DD')}",`,
            '  "time": "",',
            '  "message": "entregar o projeto final",',
            '  "type": "unica",',
            '  "isTask": true',
            '  "isRelativeTime": true',
            "}",
            "Mensagem: 'em meia hora devo escovar os dentes'",
            "Resposta:",
            "{",
            `  "dayOrDate": "${saoPauloNow.clone().add(30, 'minutes').format('YYYY-MM-DD')}",`,
            `  "time": "${saoPauloNow.clone().add(30, 'minutes').format('HH:mm')}",`,
            '  "message": "escovar os dentes",',
            '  "type": "unica"',
            '  "isRelativeTime": true',
            "}",
            "Mensagem: 'em 40 minutos devo sair'",
            "Resposta:",
            "{",
            `  "dayOrDate": "${saoPauloNow.clone().add(40, 'minutes').format('YYYY-MM-DD')}",`,
            `  "time": "${saoPauloNow.clone().add(40, 'minutes').format('HH:mm')}",`,
            '  "message": "sair",',
            '  "type": "unica"',
            '  "isRelativeTime": true',
            "}",
            "Mensagem: 'daqui duas semanas consulta com dentista √†s 09:00'",
            "Resposta:",
            "{",
            `  "dayOrDate": "${saoPauloNow.clone().add(2, 'weeks').format('YYYY-MM-DD')}",`,
            '  "time": "09:00",',
            '  "message": "consulta com dentista",',
            '  "type": "unica",',
            '  "isTask": true',
            '  "isRelativeTime": true',
            "}",
            `Mensagem: "${texto}"`
        ].join('\n');


        const resposta = await sendGroqChat(prompt, {
            systemMessage: 'Voc√™ √© um extrator de campos para cria√ß√£o de rotinas/lembretes. Responda apenas em JSON com os campos dayOrDate, time, message, type, repetition, isRelativeTime.'
        });


        if (!resposta) return null;
        // Tentar extrair JSON da resposta
        const jsonMatch = resposta.match(/\{[\s\S]*\}/);
        if (!jsonMatch) return null;


        const data = JSON.parse(jsonMatch[0]);
        console.log(`[GROQ][rotina] analisarRotinaViaGroq detectou: ${JSON.stringify(data)}`);

        // Se Groq indicar que √© hor√°rio relativo, validar o c√°lculo
        if (data.isRelativeTime === true && data.time) {
            // Tenta extrair o valor relativo do texto
            const matchMin = texto.match(/(\d+)\s*minuto|minutos/i);
            const matchHour = texto.match(/(\d+)\s*hora|horas/i);
            let esperado;
            if (matchMin) {
                const min = parseInt(matchMin[1], 10);
                esperado = saoPauloNow.clone().add(min, 'minutes');
            } else if (matchHour) {
                const hr = parseInt(matchHour[1], 10);
                esperado = saoPauloNow.clone().add(hr, 'hours');
            }
            if (esperado) {
                // Verifica se o time retornado bate com o esperado
                const timeRetornado = moment.tz(`${data.dayOrDate} ${data.time}`, "YYYY-MM-DD HH:mm", "America/Sao_Paulo");
                const diff = Math.abs(esperado.diff(timeRetornado, 'minutes'));
                if (diff > 2) { // toler√¢ncia de 2 minutos
                    // Recalcula
                    data.dayOrDate = esperado.format('YYYY-MM-DD');
                    data.time = esperado.format('HH:mm');
                    console.log('[GROQ][rotina] Hor√°rio relativo ajustado:', data.dayOrDate, data.time);
                }
            }
        }

        return {
            dayOrDate: data.dayOrDate?.toString().trim() || '',
            time: data.time?.toString().trim() || '',
            message: data.message?.toString().trim() || '',
            type: data.type?.toString().trim() || 'unica',
            repetition: data.repetition?.toString().trim() || undefined,
            isTask: typeof data.isTask === 'boolean' ? data.isTask : undefined
        };
    } catch (e) {
        console.warn(`[GROQ][rotina] Falha ao analisar rotina: ${e.message}`);
        return null;
    }
}

module.exports = {
    validarFormatoHora,
    formatRoutineResponse,
    obterRotinas: obterRotinasFromFirebase,
    scheduleRoutine,
    obterDiaDaSemana,
    iniciarLembretes,
    tratarRespostaDeLembrete,
    lembretesAtivos,
    resetarTarefasRepetitivas,
    initializeSingleReminder,
    pegarDataHoje,
    calculateNextReminder,
    calculateFirstReminder,
    processTaskCompletion,
    analisarRotinaViaGroq,
};